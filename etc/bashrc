#
# ~/.bashrc
#
#対話的に呼び出されたなら終わる
[[ $- != *i* ]] && return

#プロンプト
PS1='\[\033[01;36m\]\u@\h\[\033[00m\] \[\033[01;34m\]\w\[\033[00m\] \$ '
#PS1='\u@\h \[\033[01;34m\]\w\[\033[00m\] \[\033[01;37m\]\$\[\033[00m\] '

#重複履歴を保存しない,空白から始めたコマンドを保存しない
HISTCONTROL=ignoreboth
#履歴サイズ
HISTSIZE=10000
HISTFILESIZE=10000
#履歴に追加しないコマンド
HISTIGNORE=history:exit:cd*:ls*:ll:rm*:pushd*:dirs:popd*:tmux:poweroff:reboot:lsblk:umount*:mkdir*:rmdir*:date:tree*:unzip*:touch*:ranger:feh*:export*:which*:startx:xbacklight*:
#履歴に時刻を付ける
HISTTIMEFORMAT='%m/%d/%T | '

shopt -s checkwinsize
shopt -s autocd
shopt -s cdspell
shopt -s extglob
shopt -s globstar

[[ -x /usr/bin/lesspipe ]] && eval "$(SHELL=/bin/sh lesspipe)"
#コマンド履歴を共有
function Share_History {
    history -a #キャッシュを~/.bash_historyに書き込む
    history -c #キャッシュを削除
    history -r #キャッシュに~/.bash_histroyを書き込む
}
#プロントを表示する度に実行するコマンド
PROMPT_COMMAND='Share_History'

function ls() {
  [[ $(command ls $@) == "" ]] && command ls -FA --color=auto $@ || command ls -F --color=auto $@
}

function up() {
  #[[ $# -eq 0 ]] && set 1
  #expr $1 + 1 > /dev/null 2>&1 && \
  #   cd $(seq -s: $1 | sed 's/://g;s@.@\.\./@g') || \
  #   cd $1
  local str
  if [[ $# -eq 0 ]] && type fzf > /dev/null 2>&1; then
    str=$(pwd | sed ':a;s@/[^/]*$@@;p;/^\/[^\/]*$/!ba;d' | \
      fzf --preview='tree -C {}' --preview-window='right:hidden' --bind='ctrl-v:toggle-preview')
  elif expr ${1-dummy} + 1 > /dev/null 2>&1; then
    str=$(seq -s: $1 | sed 's/://g;s@.@\.\./@g')
  elif [[ -d $1 ]]; then
    str=$1
  fi
  command cd ${str:-.}
}
function _up() {
  COMPREPLY=( $(compgen -W "$(pwd | sed ':a;s@/[^/]*$@@;p;/^\/[^\/]*$/!ba;d')" -- ${COMP_WORDS[COMP_CWORD]}) )
}
complete -F _up up
bind C-F:menu-complete
bind C-B:menu-complete-backword

function cds() {
  local file=${HOME}/.saved_dirs
  [[ ! -e ${file} ]] && find . -maxdepth 1 -type d -not -name '.*' -printf '%f ~/%f\n' > ${file}

  function nameExists() {
    local name
    for name in $(cat ${file} | cut -d' ' -f1); do
      [[ $1 == ${name} ]] && echo 'name already used' && return 1
    done
    return 0
  }

  function directoryExists() {
    local dir
    for dir in $(cat ${file} | cut -d' ' -f2); do
      [[ $1 == ${dir} ]] && echo 'directory already exists' && return 1
    done
    return 0
  }

  function checkFile() {
    local duplicateNames=$(cat ${file} | cut -d' ' -f1 | sort | uniq -d)
    [[ -n ${duplicateNames} ]] && echo "[Duplicate name]\n${duplicateNames}\n"

    local duplicateDirectories=$(cat ${file} | cut -d' ' -f2 | sort | uniq -d)
    [[ -n ${duplicateDirectories} ]] && echo "[Duplicate directory]\n${duplicateDirectories}\n"

    local flag
    local dir
    for dir in $(cat ${file} | cut -d' ' -f2 | sort | uniq); do
      [[ -d $(echo ${dir} | sed "s@~@${HOME}@") ]] || { echo "${dir} is not directory." && flag=1; }
    done
    [[ -n ${flag} ]] && echo

    local name
    for name in $(cat ${file} | cut -d' ' -f1 | sort | uniq); do
      [[ ${name} =~ '/' ]] && echo "${name}: / cannot be used."
    done
  }

  if [[ $1 == '-s' ]]; then
    [[ -z $2 ]] && echo "\"-s\" requires at least 1 argument." && return
    nameExists $2 || return
    [[ $2 =~ '/' ]] && echo '/ cannot be used' && return
    [[ -d $3 ]] && set -- $1 $2 $(readlink -f $3 | sed "s@${HOME}@~@") || set -- $1 $2 $(pwd | sed "s@${HOME}@~@")
    directoryExists $3 || return
    echo "$2 $3" >> ${file}
  elif [[ $1 == '-l' ]]; then
    cat ${file} | xargs printf '\e[37;1m%s\e[m \e[34;1m%s\e[m\n'
  elif [[ $1 == '-e' ]]; then
    ${EDITOR} ${file}
    checkFile
  elif [[ $1 == '--delete-all' ]]; then
    echo 'delete all? (y/n)' && read input && [[ ${input} == 'y' ]] && : > ${file}
  elif [[ $1 == '-d' ]]; then
    [[ -z $2 ]] \
      && { type fzf > /dev/null 2>&1 \
      && cat ${file} | fzf --header='delete directory in the record' --preview='tree -C {}' --preview-window='right:hidden' --bind='ctrl-v:toggle-preview' | \
        xargs -I{} sed -i 's@^{}$@@;/^$/d' ${file} ;} \
      || sed -i "/^$2 /d" ${file}
  else
    local dir
    if [[ $# -ne 0 ]]; then
      dir=$(cat ${file} | grep "^$1" | head -1)
    else
      type fzf > /dev/null 2>&1 \
        && dir=$(cat ${file} | fzf --header='change directory' --preview='tree -C {}' --preview-window='right:hidden' --bind='ctrl-v:toggle-preview')
    fi
    [[ -n ${dir} ]] && eval cd $(echo ${dir} | cut -d' ' -f2)
  fi
}

# alias
alias ll='command ls -FAlht --color=auto'
alias grep='grep -i --color=auto'
alias cd='pushd > /dev/null 2>&1'
alias mv='mv -i'
alias cp='cp -i'
alias ln='ln -i'
alias rm='rm -i'
alias mkdir='mkdir -vp'
alias free='free -wh'
alias du='du -h'
alias df='df -hT'
alias dirs='dirs -v'
alias ip='ip -c'
alias nano='nano -$ -l -i -O -m -c' # オブションは個々に指定する
alias tree='tree -C'
